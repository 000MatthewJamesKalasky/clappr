{"version":3,"file":"hlsjs-playback.external.min.js","sources":["../src/hls.js"],"sourcesContent":["// Copyright 2014 Globo.com Player authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\nimport { Events, HTML5Video, Log, Playback, PlayerError, Utils } from '@clappr/core'\nimport HLSJS from 'hls.js'\n\nconst { now, assign, listContainsIgnoreCase } = Utils\n\nconst AUTO = -1\n\nexport default class HlsjsPlayback extends HTML5Video {\n  get name() { return 'hls' }\n\n  get supportedVersion() { return { min: CLAPPR_CORE_VERSION } }\n\n  get levels() { return this._levels || [] }\n\n  get currentLevel() {\n    if (this._currentLevel === null || this._currentLevel === undefined)\n      return AUTO\n    else\n      return this._currentLevel //0 is a valid level ID\n\n  }\n\n  get isReady() {\n    return this._isReadyState\n  }\n\n  set currentLevel(id) {\n    this._currentLevel = id\n    this.trigger(Events.PLAYBACK_LEVEL_SWITCH_START)\n    if (this.options.playback.hlsUseNextLevel)\n      this._hls.nextLevel = this._currentLevel\n    else\n      this._hls.currentLevel = this._currentLevel\n  }\n\n  get _startTime() {\n    if (this._playbackType === Playback.LIVE && this._playlistType !== 'EVENT')\n      return this._extrapolatedStartTime\n\n    return this._playableRegionStartTime\n  }\n\n  get _now() {\n    return now()\n  }\n\n  // the time in the video element which should represent the start of the sliding window\n  // extrapolated to increase in real time (instead of jumping as the early segments are removed)\n  get _extrapolatedStartTime() {\n    if (!this._localStartTimeCorrelation)\n      return this._playableRegionStartTime\n\n    let corr = this._localStartTimeCorrelation\n    let timePassed = this._now - corr.local\n    let extrapolatedWindowStartTime = (corr.remote + timePassed) / 1000\n    // cap at the end of the extrapolated window duration\n    return Math.min(extrapolatedWindowStartTime, this._playableRegionStartTime + this._extrapolatedWindowDuration)\n  }\n\n  // the time in the video element which should represent the end of the content\n  // extrapolated to increase in real time (instead of jumping as segments are added)\n  get _extrapolatedEndTime() {\n    let actualEndTime = this._playableRegionStartTime + this._playableRegionDuration\n    if (!this._localEndTimeCorrelation)\n      return actualEndTime\n\n    let corr = this._localEndTimeCorrelation\n    let timePassed = this._now - corr.local\n    let extrapolatedEndTime = (corr.remote + timePassed) / 1000\n    return Math.max(actualEndTime - this._extrapolatedWindowDuration, Math.min(extrapolatedEndTime, actualEndTime))\n  }\n\n  get _duration() {\n    return this._extrapolatedEndTime - this._startTime\n  }\n\n  // Returns the duration (seconds) of the window that the extrapolated start time is allowed\n  // to move in before being capped.\n  // The extrapolated start time should never reach the cap at the end of the window as the\n  // window should slide as chunks are removed from the start.\n  // This also applies to the extrapolated end time in the same way.\n  //\n  // If chunks aren't being removed for some reason that the start time will reach and remain fixed at\n  // playableRegionStartTime + extrapolatedWindowDuration\n  //\n  //                                <-- window duration -->\n  // I.e   playableRegionStartTime |-----------------------|\n  //                               | -->   .       .       .\n  //                               .   --> | -->   .       .\n  //                               .       .   --> | -->   .\n  //                               .       .       .   --> |\n  //                               .       .       .       .\n  //                                 extrapolatedStartTime\n  get _extrapolatedWindowDuration() {\n    if (this._segmentTargetDuration === null)\n      return 0\n\n    return this._extrapolatedWindowNumSegments * this._segmentTargetDuration\n  }\n\n  static get HLSJS() {\n    return HLSJS\n  }\n\n  constructor(...args) {\n    super(...args)\n    // backwards compatibility (TODO: remove on 0.3.0)\n    this.options.playback = { ...this.options, ...this.options.playback }\n    this._minDvrSize = typeof (this.options.hlsMinimumDvrSize) === 'undefined' ? 60 : this.options.hlsMinimumDvrSize\n    // The size of the start time extrapolation window measured as a multiple of segments.\n    // Should be 2 or higher, or 0 to disable. Should only need to be increased above 2 if more than one segment is\n    // removed from the start of the playlist at a time. E.g if the playlist is cached for 10 seconds and new chunks are\n    // added/removed every 5.\n    this._extrapolatedWindowNumSegments = !this.options.playback || typeof (this.options.playback.extrapolatedWindowNumSegments) === 'undefined' ? 2 :  this.options.playback.extrapolatedWindowNumSegments\n\n    this._playbackType = Playback.VOD\n    this._lastTimeUpdate = { current: 0, total: 0 }\n    this._lastDuration = null\n    // for hls streams which have dvr with a sliding window,\n    // the content at the start of the playlist is removed as new\n    // content is appended at the end.\n    // this means the actual playable start time will increase as the\n    // start content is deleted\n    // For streams with dvr where the entire recording is kept from the\n    // beginning this should stay as 0\n    this._playableRegionStartTime = 0\n    // {local, remote} remote is the time in the video element that should represent 0\n    //                 local is the system time when the 'remote' measurment took place\n    this._localStartTimeCorrelation = null\n    // {local, remote} remote is the time in the video element that should represents the end\n    //                 local is the system time when the 'remote' measurment took place\n    this._localEndTimeCorrelation = null\n    // if content is removed from the beginning then this empty area should\n    // be ignored. \"playableRegionDuration\" excludes the empty area\n    this._playableRegionDuration = 0\n    // #EXT-X-PROGRAM-DATE-TIME\n    this._programDateTime = 0\n    // true when the actual duration is longer than hlsjs's live sync point\n    // when this is false playableRegionDuration will be the actual duration\n    // when this is true playableRegionDuration will exclude the time after the sync point\n    this._durationExcludesAfterLiveSyncPoint = false\n    // #EXT-X-TARGETDURATION\n    this._segmentTargetDuration = null\n    // #EXT-X-PLAYLIST-TYPE\n    this._playlistType = null\n    this._recoverAttemptsRemaining = this.options.hlsRecoverAttempts || 16\n  }\n\n  _setup() {\n    this._ccIsSetup = false\n    this._ccTracksUpdated = false\n    this._hls = new HLSJS(assign({}, this.options.playback.hlsjsConfig))\n    this._hls.once(HLSJS.Events.MEDIA_ATTACHED, () => this._hls.loadSource(this.options.src))\n    this._hls.on(HLSJS.Events.LEVEL_LOADED, (evt, data) => this._updatePlaybackType(evt, data))\n    this._hls.on(HLSJS.Events.LEVEL_UPDATED, (evt, data) => this._onLevelUpdated(evt, data))\n    this._hls.on(HLSJS.Events.LEVEL_SWITCHING, (evt,data) => this._onLevelSwitch(evt, data))\n    this._hls.on(HLSJS.Events.FRAG_LOADED, (evt, data) => this._onFragmentLoaded(evt, data))\n    this._hls.on(HLSJS.Events.ERROR, (evt, data) => this._onHLSJSError(evt, data))\n    this._hls.on(HLSJS.Events.SUBTITLE_TRACK_LOADED, (evt, data) => this._onSubtitleLoaded(evt, data))\n    this._hls.on(HLSJS.Events.SUBTITLE_TRACKS_UPDATED, () => this._ccTracksUpdated = true)\n    this._hls.attachMedia(this.el)\n  }\n\n  render() {\n    this._ready()\n    return super.render()\n  }\n\n  _ready() {\n    this._isReadyState = true\n    this.trigger(Events.PLAYBACK_READY, this.name)\n  }\n\n  _recover(evt, data, error) {\n    if (!this._recoveredDecodingError) {\n      this._recoveredDecodingError = true\n      this._hls.recoverMediaError()\n    } else if (!this._recoveredAudioCodecError) {\n      this._recoveredAudioCodecError = true\n      this._hls.swapAudioCodec()\n      this._hls.recoverMediaError()\n    } else {\n      Log.error('hlsjs: failed to recover', { evt, data })\n      error.level = PlayerError.Levels.FATAL\n      const formattedError = this.createError(error)\n      this.trigger(Events.PLAYBACK_ERROR, formattedError)\n      this.stop()\n    }\n  }\n\n  // override\n  _setupSrc(srcUrl) { // eslint-disable-line no-unused-vars\n    // this playback manages the src on the video element itself\n  }\n\n  _startTimeUpdateTimer() {\n    if (this._timeUpdateTimer) return\n\n    this._timeUpdateTimer = setInterval(() => {\n      this._onDurationChange()\n      this._onTimeUpdate()\n    }, 100)\n  }\n\n  _stopTimeUpdateTimer() {\n    if (!this._timeUpdateTimer) return\n\n    clearInterval(this._timeUpdateTimer)\n    this._timeUpdateTimer = null\n  }\n\n  getProgramDateTime() {\n    return this._programDateTime\n  }\n  // the duration on the video element itself should not be used\n  // as this does not necesarily represent the duration of the stream\n  // https://github.com/clappr/clappr/issues/668#issuecomment-157036678\n  getDuration() {\n    return this._duration\n  }\n\n  getCurrentTime() {\n    // e.g. can be < 0 if user pauses near the start\n    // eventually they will then be kicked to the end by hlsjs if they run out of buffer\n    // before the official start time\n    return Math.max(0, this.el.currentTime - this._startTime)\n  }\n\n  // the time that \"0\" now represents relative to when playback started\n  // for a stream with a sliding window this will increase as content is\n  // removed from the beginning\n  getStartTimeOffset() {\n    return this._startTime\n  }\n\n  seekPercentage(percentage) {\n    let seekTo = this._duration\n    if (percentage > 0)\n      seekTo = this._duration * (percentage / 100)\n\n    this.seek(seekTo)\n  }\n\n  seek(time) {\n    if (time < 0) {\n      Log.warn('Attempt to seek to a negative time. Resetting to live point. Use seekToLivePoint() to seek to the live point.')\n      time = this.getDuration()\n    }\n    // assume live if time within 3 seconds of end of stream\n    this.dvrEnabled && this._updateDvr(time < this.getDuration()-3)\n    time += this._startTime\n    super.seek(time)\n  }\n\n  seekToLivePoint() {\n    this.seek(this.getDuration())\n  }\n\n  _updateDvr(status) {\n    this.trigger(Events.PLAYBACK_DVR, status)\n    this.trigger(Events.PLAYBACK_STATS_ADD, { 'dvr': status })\n  }\n\n  _updateSettings() {\n    if (this._playbackType === Playback.VOD)\n      this.settings.left = ['playpause', 'position', 'duration']\n    else if (this.dvrEnabled)\n      this.settings.left = ['playpause']\n    else\n      this.settings.left = ['playstop']\n\n    this.settings.seekEnabled = this.isSeekEnabled()\n    this.trigger(Events.PLAYBACK_SETTINGSUPDATE)\n  }\n\n  _onHLSJSError(evt, data) {\n    const error = {\n      code: `${data.type}_${data.details}`,\n      description: `${this.name} error: type: ${data.type}, details: ${data.details}`,\n      raw: data,\n    }\n    let formattedError\n    if (data.response) error.description += `, response: ${JSON.stringify(data.response)}`\n    // only report/handle errors if they are fatal\n    // hlsjs should automatically handle non fatal errors\n    if (data.fatal) {\n      if (this._recoverAttemptsRemaining > 0) {\n        this._recoverAttemptsRemaining -= 1\n        switch (data.type) {\n        case HLSJS.ErrorTypes.NETWORK_ERROR:\n          switch (data.details) {\n          // The following network errors cannot be recovered with HLS.startLoad()\n          // For more details, see https://github.com/video-dev/hls.js/blob/master/doc/design.md#error-detection-and-handling\n          // For \"level load\" fatal errors, see https://github.com/video-dev/hls.js/issues/1138\n          case HLSJS.ErrorDetails.MANIFEST_LOAD_ERROR:\n          case HLSJS.ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n          case HLSJS.ErrorDetails.MANIFEST_PARSING_ERROR:\n          case HLSJS.ErrorDetails.LEVEL_LOAD_ERROR:\n          case HLSJS.ErrorDetails.LEVEL_LOAD_TIMEOUT:\n            Log.error('hlsjs: unrecoverable network fatal error.', { evt, data })\n            formattedError = this.createError(error)\n            this.trigger(Events.PLAYBACK_ERROR, formattedError)\n            this.stop()\n            break\n          default:\n            Log.warn('hlsjs: trying to recover from network error.', { evt, data })\n            error.level = PlayerError.Levels.WARN\n            this._hls.startLoad()\n            break\n          }\n          break\n        case HLSJS.ErrorTypes.MEDIA_ERROR:\n          Log.warn('hlsjs: trying to recover from media error.', { evt, data })\n          error.level = PlayerError.Levels.WARN\n          this._recover(evt, data, error)\n          break\n        default:\n          Log.error('hlsjs: could not recover from error.', { evt, data })\n          formattedError = this.createError(error)\n          this.trigger(Events.PLAYBACK_ERROR, formattedError)\n          this.stop()\n          break\n        }\n      } else {\n        Log.error('hlsjs: could not recover from error after maximum number of attempts.', { evt, data })\n        formattedError = this.createError(error)\n        this.trigger(Events.PLAYBACK_ERROR, formattedError)\n        this.stop()\n      }\n    } else {\n      // Transforms HLSJS.ErrorDetails.KEY_LOAD_ERROR non-fatal error to\n      // playback fatal error if triggerFatalErrorOnResourceDenied playback\n      // option is set. HLSJS.ErrorTypes.KEY_SYSTEM_ERROR are fatal errors\n      // and therefore already handled.\n      if (this.options.playback.triggerFatalErrorOnResourceDenied && this._keyIsDenied(data)) {\n        Log.error('hlsjs: could not load decrypt key.', { evt, data })\n        formattedError = this.createError(error)\n        this.trigger(Events.PLAYBACK_ERROR, formattedError)\n        this.stop()\n        return\n      }\n\n      error.level = PlayerError.Levels.WARN\n      Log.warn('hlsjs: non-fatal error occurred', { evt, data })\n    }\n  }\n\n  _keyIsDenied(data) {\n    return data.type === HLSJS.ErrorTypes.NETWORK_ERROR\n      && data.details === HLSJS.ErrorDetails.KEY_LOAD_ERROR\n      && data.response\n      && data.response.code >= 400\n  }\n\n  _onTimeUpdate() {\n    let update = { current: this.getCurrentTime(), total: this.getDuration(), firstFragDateTime: this.getProgramDateTime() }\n    let isSame = this._lastTimeUpdate && (\n      update.current === this._lastTimeUpdate.current &&\n      update.total === this._lastTimeUpdate.total)\n    if (isSame)\n      return\n\n    this._lastTimeUpdate = update\n    this.trigger(Events.PLAYBACK_TIMEUPDATE, update, this.name)\n  }\n\n  _onDurationChange() {\n    let duration = this.getDuration()\n    if (this._lastDuration === duration)\n      return\n\n    this._lastDuration = duration\n    super._onDurationChange()\n  }\n\n  _onProgress() {\n    if (!this.el.buffered.length)\n      return\n\n    let buffered = []\n    let bufferedPos = 0\n    for (let i = 0; i < this.el.buffered.length; i++) {\n      buffered = [...buffered, {\n        // for a stream with sliding window dvr something that is buffered my slide off the start of the timeline\n        start: Math.max(0, this.el.buffered.start(i) - this._playableRegionStartTime),\n        end: Math.max(0, this.el.buffered.end(i) - this._playableRegionStartTime)\n      }]\n      if (this.el.currentTime >= buffered[i].start && this.el.currentTime <= buffered[i].end)\n        bufferedPos = i\n\n    }\n    const progress = {\n      start: buffered[bufferedPos].start,\n      current: buffered[bufferedPos].end,\n      total: this.getDuration()\n    }\n    this.trigger(Events.PLAYBACK_PROGRESS, progress, buffered)\n  }\n\n  play() {\n    if (!this._hls)\n      this._setup()\n\n    super.play()\n    this._startTimeUpdateTimer()\n  }\n\n  pause() {\n    if (!this._hls)\n      return\n\n    super.pause()\n    if (this.dvrEnabled)\n      this._updateDvr(true)\n\n  }\n\n  stop() {\n    this._stopTimeUpdateTimer()\n    if (this._hls) {\n      super.stop()\n      this._hls.destroy()\n      delete this._hls\n    }\n  }\n\n  destroy() {\n    this._stopTimeUpdateTimer()\n    if (this._hls) {\n      this._hls.destroy()\n      delete this._hls\n    }\n    super.destroy()\n  }\n\n  _updatePlaybackType(evt, data) {\n    this._playbackType = data.details.live ? Playback.LIVE : Playback.VOD\n    this._onLevelUpdated(evt, data)\n\n    // Live stream subtitle tracks detection hack (may not immediately available)\n    if (this._ccTracksUpdated && this._playbackType === Playback.LIVE && this.hasClosedCaptionsTracks)\n      this._onSubtitleLoaded()\n\n  }\n\n  _fillLevels() {\n    this._levels = this._hls.levels.map((level, index) => {\n      return { id: index, level: level, label: `${level.bitrate/1000}Kbps` }\n    })\n    this.trigger(Events.PLAYBACK_LEVELS_AVAILABLE, this._levels)\n  }\n\n  _onLevelUpdated(evt, data) {\n    this._segmentTargetDuration = data.details.targetduration\n    this._playlistType = data.details.type || null\n\n    let startTimeChanged = false\n    let durationChanged = false\n    let fragments = data.details.fragments\n    let previousPlayableRegionStartTime = this._playableRegionStartTime\n    let previousPlayableRegionDuration = this._playableRegionDuration\n\n    if (fragments.length === 0)\n      return\n\n\n    // #EXT-X-PROGRAM-DATE-TIME\n    if (fragments[0].rawProgramDateTime)\n      this._programDateTime = fragments[0].rawProgramDateTime\n\n\n    if (this._playableRegionStartTime !== fragments[0].start) {\n      startTimeChanged = true\n      this._playableRegionStartTime = fragments[0].start\n    }\n\n    if (startTimeChanged) {\n      if (!this._localStartTimeCorrelation) {\n        // set the correlation to map to middle of the extrapolation window\n        this._localStartTimeCorrelation = {\n          local: this._now,\n          remote: (fragments[0].start + (this._extrapolatedWindowDuration/2)) * 1000\n        }\n      } else {\n        // check if the correlation still works\n        let corr = this._localStartTimeCorrelation\n        let timePassed = this._now - corr.local\n        // this should point to a time within the extrapolation window\n        let startTime = (corr.remote + timePassed) / 1000\n        if (startTime < fragments[0].start) {\n          // our start time is now earlier than the first chunk\n          // (maybe the chunk was removed early)\n          // reset correlation so that it sits at the beginning of the first available chunk\n          this._localStartTimeCorrelation = {\n            local: this._now,\n            remote: fragments[0].start * 1000\n          }\n        } else if (startTime > previousPlayableRegionStartTime + this._extrapolatedWindowDuration) {\n          // start time was past the end of the old extrapolation window (so would have been capped)\n          // see if now that time would be inside the window, and if it would be set the correlation\n          // so that it resumes from the time it was at at the end of the old window\n          // update the correlation so that the time starts counting again from the value it's on now\n          this._localStartTimeCorrelation = {\n            local: this._now,\n            remote: Math.max(fragments[0].start, previousPlayableRegionStartTime + this._extrapolatedWindowDuration) * 1000\n          }\n        }\n      }\n    }\n\n    let newDuration = data.details.totalduration\n    // if it's a live stream then shorten the duration to remove access\n    // to the area after hlsjs's live sync point\n    // seeks to areas after this point sometimes have issues\n    if (this._playbackType === Playback.LIVE) {\n      let fragmentTargetDuration = data.details.targetduration\n      let hlsjsConfig = this.options.playback.hlsjsConfig || {}\n      let liveSyncDurationCount = hlsjsConfig.liveSyncDurationCount || HLSJS.DefaultConfig.liveSyncDurationCount\n      let hiddenAreaDuration = fragmentTargetDuration * liveSyncDurationCount\n      if (hiddenAreaDuration <= newDuration) {\n        newDuration -= hiddenAreaDuration\n        this._durationExcludesAfterLiveSyncPoint = true\n      } else { this._durationExcludesAfterLiveSyncPoint = false }\n\n    }\n\n    if (newDuration !== this._playableRegionDuration) {\n      durationChanged = true\n      this._playableRegionDuration = newDuration\n    }\n\n    // Note the end time is not the playableRegionDuration\n    // The end time will always increase even if content is removed from the beginning\n    let endTime = fragments[0].start + newDuration\n    let previousEndTime = previousPlayableRegionStartTime + previousPlayableRegionDuration\n    let endTimeChanged = endTime !== previousEndTime\n    if (endTimeChanged) {\n      if (!this._localEndTimeCorrelation) {\n        // set the correlation to map to the end\n        this._localEndTimeCorrelation = {\n          local: this._now,\n          remote: endTime * 1000\n        }\n      } else {\n        // check if the correlation still works\n        let corr = this._localEndTimeCorrelation\n        let timePassed = this._now - corr.local\n        // this should point to a time within the extrapolation window from the end\n        let extrapolatedEndTime = (corr.remote + timePassed) / 1000\n        if (extrapolatedEndTime > endTime) {\n          this._localEndTimeCorrelation = {\n            local: this._now,\n            remote: endTime * 1000\n          }\n        } else if (extrapolatedEndTime < endTime - this._extrapolatedWindowDuration) {\n          // our extrapolated end time is now earlier than the extrapolation window from the actual end time\n          // (maybe a chunk became available early)\n          // reset correlation so that it sits at the beginning of the extrapolation window from the end time\n          this._localEndTimeCorrelation = {\n            local: this._now,\n            remote: (endTime - this._extrapolatedWindowDuration) * 1000\n          }\n        } else if (extrapolatedEndTime > previousEndTime) {\n          // end time was past the old end time (so would have been capped)\n          // set the correlation so that it resumes from the time it was at at the end of the old window\n          this._localEndTimeCorrelation = {\n            local: this._now,\n            remote: previousEndTime * 1000\n          }\n        }\n      }\n    }\n\n    // now that the values have been updated call any methods that use on them so they get the updated values\n    // immediately\n    durationChanged && this._onDurationChange()\n    startTimeChanged && this._onProgress()\n  }\n\n  _onFragmentLoaded(evt, data) {\n    this.trigger(Events.PLAYBACK_FRAGMENT_LOADED, data)\n  }\n\n  _onSubtitleLoaded() {\n    // This event may be triggered multiple times\n    // Setup CC only once (disable CC by default)\n    if (!this._ccIsSetup) {\n      this.trigger(Events.PLAYBACK_SUBTITLE_AVAILABLE)\n      const trackId = this._playbackType === Playback.LIVE ? -1 : this.closedCaptionsTrackId\n      this.closedCaptionsTrackId = trackId\n      this._ccIsSetup = true\n    }\n  }\n\n  _onLevelSwitch(evt, data) {\n    if (!this.levels.length)\n      this._fillLevels()\n\n    this.trigger(Events.PLAYBACK_LEVEL_SWITCH_END)\n    this.trigger(Events.PLAYBACK_LEVEL_SWITCH, data)\n    let currentLevel = this._hls.levels[data.level]\n    if (currentLevel) {\n      // TODO should highDefinition be private and maybe have a read only accessor if it's used somewhere\n      this.highDefinition = (currentLevel.height >= 720 || (currentLevel.bitrate / 1000) >= 2000)\n      this.trigger(Events.PLAYBACK_HIGHDEFINITIONUPDATE, this.highDefinition)\n      this.trigger(Events.PLAYBACK_BITRATE, {\n        height: currentLevel.height,\n        width: currentLevel.width,\n        bandwidth: currentLevel.bitrate,\n        bitrate: currentLevel.bitrate,\n        level: data.level\n      })\n    }\n  }\n\n  get dvrEnabled() {\n    // enabled when:\n    // - the duration does not include content after hlsjs's live sync point\n    // - the playable region duration is longer than the configured duration to enable dvr after\n    // - the playback type is LIVE.\n    return (this._durationExcludesAfterLiveSyncPoint && this._duration >= this._minDvrSize && this.getPlaybackType() === Playback.LIVE)\n  }\n\n  getPlaybackType() {\n    return this._playbackType\n  }\n\n  isSeekEnabled() {\n    return (this._playbackType === Playback.VOD || this.dvrEnabled)\n  }\n}\n\nHlsjsPlayback.canPlay = function(resource, mimeType) {\n  const resourceParts = resource.split('?')[0].match(/.*\\.(.*)$/) || []\n  const isHls = ((resourceParts.length > 1 && resourceParts[1].toLowerCase() === 'm3u8') || listContainsIgnoreCase(mimeType, ['application/vnd.apple.mpegurl', 'application/x-mpegURL']))\n\n  return !!(HLSJS.isSupported() && isHls)\n}\n"],"names":["now","Utils","assign","listContainsIgnoreCase","HlsjsPlayback","args","options","playback","_this","_minDvrSize","hlsMinimumDvrSize","_extrapolatedWindowNumSegments","extrapolatedWindowNumSegments","_playbackType","Playback","VOD","_lastTimeUpdate","current","total","_lastDuration","_playableRegionStartTime","_localStartTimeCorrelation","_localEndTimeCorrelation","_playableRegionDuration","_programDateTime","_durationExcludesAfterLiveSyncPoint","_segmentTargetDuration","_playlistType","_recoverAttemptsRemaining","hlsRecoverAttempts","min","this","_levels","_currentLevel","undefined","id","trigger","Events","PLAYBACK_LEVEL_SWITCH_START","hlsUseNextLevel","_hls","nextLevel","currentLevel","_isReadyState","LIVE","_extrapolatedStartTime","corr","timePassed","_now","local","extrapolatedWindowStartTime","remote","Math","_extrapolatedWindowDuration","actualEndTime","extrapolatedEndTime","max","_extrapolatedEndTime","_startTime","HLSJS","_ccIsSetup","_ccTracksUpdated","hlsjsConfig","once","MEDIA_ATTACHED","_this2","loadSource","src","on","LEVEL_LOADED","evt","data","_updatePlaybackType","LEVEL_UPDATED","_onLevelUpdated","LEVEL_SWITCHING","_onLevelSwitch","FRAG_LOADED","_onFragmentLoaded","ERROR","_onHLSJSError","SUBTITLE_TRACK_LOADED","_onSubtitleLoaded","SUBTITLE_TRACKS_UPDATED","attachMedia","el","_ready","PLAYBACK_READY","name","error","_recoveredDecodingError","_recoveredAudioCodecError","Log","level","PlayerError","Levels","FATAL","formattedError","createError","PLAYBACK_ERROR","stop","swapAudioCodec","recoverMediaError","srcUrl","_timeUpdateTimer","setInterval","_this3","_onDurationChange","_onTimeUpdate","clearInterval","_duration","currentTime","percentage","seekTo","seek","time","warn","getDuration","dvrEnabled","_updateDvr","status","PLAYBACK_DVR","PLAYBACK_STATS_ADD","settings","left","seekEnabled","isSeekEnabled","PLAYBACK_SETTINGSUPDATE","code","type","details","description","raw","response","JSON","stringify","fatal","ErrorTypes","NETWORK_ERROR","ErrorDetails","MANIFEST_LOAD_ERROR","MANIFEST_LOAD_TIMEOUT","MANIFEST_PARSING_ERROR","LEVEL_LOAD_ERROR","LEVEL_LOAD_TIMEOUT","WARN","startLoad","MEDIA_ERROR","_recover","triggerFatalErrorOnResourceDenied","_keyIsDenied","KEY_LOAD_ERROR","update","getCurrentTime","firstFragDateTime","getProgramDateTime","PLAYBACK_TIMEUPDATE","duration","buffered","length","bufferedPos","i","start","end","progress","PLAYBACK_PROGRESS","_setup","_startTimeUpdateTimer","_stopTimeUpdateTimer","destroy","live","hasClosedCaptionsTracks","levels","map","index","label","bitrate","PLAYBACK_LEVELS_AVAILABLE","targetduration","startTimeChanged","durationChanged","fragments","previousPlayableRegionStartTime","previousPlayableRegionDuration","rawProgramDateTime","startTime","newDuration","totalduration","hiddenAreaDuration","liveSyncDurationCount","DefaultConfig","endTime","previousEndTime","_onProgress","PLAYBACK_FRAGMENT_LOADED","PLAYBACK_SUBTITLE_AVAILABLE","trackId","closedCaptionsTrackId","_fillLevels","PLAYBACK_LEVEL_SWITCH_END","PLAYBACK_LEVEL_SWITCH","highDefinition","height","PLAYBACK_HIGHDEFINITIONUPDATE","PLAYBACK_BITRATE","width","bandwidth","getPlaybackType","HTML5Video","canPlay","resource","mimeType","resourceParts","split","match","isHls","toLowerCase","isSupported"],"mappings":"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"}